"""
User and Entity Behavior Analytics (UEBA) Service
Implements behavioral profiling for insider threat and compromised account detection.

Key Features:
- Dynamic baseline learning per user/device
- Behavioral deviation scoring
- Peer group comparison
- Insider threat detection
- Compromised credential detection
"""
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Set, Tuple
from collections import defaultdict
import numpy as np
from dataclasses import dataclass, field
from enum import Enum

from models.flow import NetworkFlow
from models.device import Device, DeviceRole, NetworkZone


class RiskFactor(str, Enum):
    """Risk factors for UEBA scoring"""
    UNUSUAL_TIME = "unusual_time"
    UNUSUAL_DESTINATION = "unusual_destination"
    UNUSUAL_VOLUME = "unusual_volume"
    UNUSUAL_PROTOCOL = "unusual_protocol"
    FIRST_TIME_ACCESS = "first_time_access"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    DATA_HOARDING = "data_hoarding"
    PEER_DEVIATION = "peer_deviation"


@dataclass
class BehaviorProfile:
    """
    Behavioral profile for a user or entity.
    Tracks historical patterns to detect anomalies.
    """
    entity_id: str  # IP or user ID
    entity_type: str  # 'user', 'device', 'service'
    role: str = "unknown"
    zone: str = "unknown"
    
    # Activity patterns
    active_hours: List[int] = field(default_factory=lambda: [0] * 24)
    active_days: List[int] = field(default_factory=lambda: [0] * 7)
    
    # Destinations accessed
    destinations: Dict[str, int] = field(default_factory=dict)
    ports_used: Dict[int, int] = field(default_factory=dict)
    protocols_used: Dict[str, int] = field(default_factory=dict)
    
    # Traffic patterns
    hourly_bytes: List[float] = field(default_factory=lambda: [0.0] * 24)
    hourly_connections: List[int] = field(default_factory=lambda: [0] * 24)
    
    # Resource access
    resources_accessed: Set[str] = field(default_factory=set)
    failed_logins: int = 0
    successful_logins: int = 0
    
    # Statistical baselines
    avg_bytes_per_hour: float = 0.0
    std_bytes_per_hour: float = 0.0
    avg_connections_per_hour: float = 0.0
    std_connections_per_hour: float = 0.0
    
    # Risk tracking
    risk_score: float = 0.0
    risk_factors: List[str] = field(default_factory=list)
    last_risk_update: datetime = field(default_factory=datetime.now)
    
    # Metadata
    first_seen: datetime = field(default_factory=datetime.now)
    last_seen: datetime = field(default_factory=datetime.now)
    profile_age_hours: float = 0.0
    observation_count: int = 0


@dataclass
class UEBAAlert:
    """Alert generated by UEBA analysis"""
    alert_id: str
    entity_id: str
    entity_type: str
    risk_score: float
    risk_factors: List[str]
    description: str
    evidence: Dict
    timestamp: datetime = field(default_factory=datetime.now)
    severity: str = "medium"


class UEBAService:
    """
    User and Entity Behavior Analytics Service.
    
    Implements the UEBA component of the AIDS:
    1. Dynamic behavioral profiling
    2. Baseline learning
    3. Anomaly scoring
    4. Insider threat detection
    5. Compromised account detection
    """
    
    def __init__(self):
        self.profiles: Dict[str, BehaviorProfile] = {}
        self.alerts: List[UEBAAlert] = []
        self.peer_groups: Dict[str, List[str]] = defaultdict(list)  # role -> entity_ids
        
        # Detection thresholds
        self.thresholds = {
            "unusual_hour_threshold": 0.1,  # Activity in hours with <10% baseline
            "volume_deviation_threshold": 3.0,  # 3 std deviations
            "new_destination_risk": 0.3,
            "peer_deviation_threshold": 2.0,
            "data_hoarding_threshold": 5.0,  # 5x normal volume
            "failed_login_threshold": 5,
            "min_observations_for_baseline": 10
        }
    
    def get_or_create_profile(self, entity_id: str, entity_type: str = "device", 
                              role: str = "unknown", zone: str = "unknown") -> BehaviorProfile:
        """Get existing profile or create new one"""
        if entity_id not in self.profiles:
            self.profiles[entity_id] = BehaviorProfile(
                entity_id=entity_id,
                entity_type=entity_type,
                role=role,
                zone=zone
            )
            # Add to peer group
            self.peer_groups[role].append(entity_id)
        
        return self.profiles[entity_id]
    
    def update_profile_from_flow(self, flow: NetworkFlow, 
                                  src_role: str = "unknown", 
                                  src_zone: str = "unknown"):
        """
        Update behavioral profile based on observed network flow.
        This is called for each flow to build/update the baseline.
        """
        profile = self.get_or_create_profile(
            flow.source_ip, "device", src_role, src_zone
        )
        
        # Update timing patterns
        hour = flow.start_time.hour
        day = flow.start_time.weekday()
        
        profile.active_hours[hour] += 1
        profile.active_days[day] += 1
        
        # Update destination patterns
        profile.destinations[flow.dest_ip] = profile.destinations.get(flow.dest_ip, 0) + 1
        profile.ports_used[flow.dest_port] = profile.ports_used.get(flow.dest_port, 0) + 1
        profile.protocols_used[flow.protocol.value] = profile.protocols_used.get(flow.protocol.value, 0) + 1
        
        # Update traffic patterns
        bytes_total = flow.bytes_sent + flow.bytes_received
        profile.hourly_bytes[hour] += bytes_total
        profile.hourly_connections[hour] += 1
        
        # Update metadata
        profile.last_seen = datetime.now()
        profile.observation_count += 1
        
        # Recalculate baselines if enough observations
        if profile.observation_count >= self.thresholds["min_observations_for_baseline"]:
            self._update_baselines(profile)
    
    def _update_baselines(self, profile: BehaviorProfile):
        """Recalculate statistical baselines for a profile"""
        # Bytes per hour baseline
        active_hours_data = [b for b in profile.hourly_bytes if b > 0]
        if active_hours_data:
            profile.avg_bytes_per_hour = np.mean(active_hours_data)
            profile.std_bytes_per_hour = np.std(active_hours_data) if len(active_hours_data) > 1 else profile.avg_bytes_per_hour * 0.5
        
        # Connections per hour baseline
        active_conn_data = [c for c in profile.hourly_connections if c > 0]
        if active_conn_data:
            profile.avg_connections_per_hour = np.mean(active_conn_data)
            profile.std_connections_per_hour = np.std(active_conn_data) if len(active_conn_data) > 1 else profile.avg_connections_per_hour * 0.5
        
        # Update profile age
        profile.profile_age_hours = (datetime.now() - profile.first_seen).total_seconds() / 3600
    
    def analyze_flow_for_anomalies(self, flow: NetworkFlow) -> Optional[UEBAAlert]:
        """
        Analyze a flow against the entity's behavioral profile.
        Returns an alert if anomalies are detected.
        """
        profile = self.profiles.get(flow.source_ip)
        if not profile or profile.observation_count < self.thresholds["min_observations_for_baseline"]:
            return None
        
        risk_factors = []
        evidence = {}
        risk_score = 0.0
        
        hour = flow.start_time.hour
        
        # Check 1: Unusual time of activity
        total_hour_activity = sum(profile.active_hours)
        if total_hour_activity > 0:
            hour_ratio = profile.active_hours[hour] / total_hour_activity
            if hour_ratio < self.thresholds["unusual_hour_threshold"]:
                risk_factors.append(RiskFactor.UNUSUAL_TIME.value)
                risk_score += 0.2
                evidence["unusual_hour"] = {
                    "current_hour": hour,
                    "hour_activity_ratio": round(hour_ratio, 4),
                    "threshold": self.thresholds["unusual_hour_threshold"]
                }
        
        # Check 2: New/unusual destination
        if flow.dest_ip not in profile.destinations:
            risk_factors.append(RiskFactor.FIRST_TIME_ACCESS.value)
            risk_score += self.thresholds["new_destination_risk"]
            evidence["new_destination"] = flow.dest_ip
        
        # Check 3: Unusual traffic volume
        bytes_total = flow.bytes_sent + flow.bytes_received
        if profile.std_bytes_per_hour > 0:
            bytes_deviation = abs(bytes_total - profile.avg_bytes_per_hour) / profile.std_bytes_per_hour
            if bytes_deviation > self.thresholds["volume_deviation_threshold"]:
                risk_factors.append(RiskFactor.UNUSUAL_VOLUME.value)
                risk_score += min(0.3, bytes_deviation * 0.05)
                evidence["volume_deviation"] = {
                    "current_bytes": bytes_total,
                    "avg_bytes": round(profile.avg_bytes_per_hour, 2),
                    "deviation_score": round(bytes_deviation, 2)
                }
        
        # Check 4: Unusual protocol
        if flow.protocol.value not in profile.protocols_used:
            risk_factors.append(RiskFactor.UNUSUAL_PROTOCOL.value)
            risk_score += 0.15
            evidence["new_protocol"] = flow.protocol.value
        
        # Check 5: Peer group deviation
        peer_deviation = self._calculate_peer_deviation(profile, flow)
        if peer_deviation > self.thresholds["peer_deviation_threshold"]:
            risk_factors.append(RiskFactor.PEER_DEVIATION.value)
            risk_score += 0.25
            evidence["peer_deviation"] = round(peer_deviation, 2)
        
        # Generate alert if risk score is significant
        if risk_score >= 0.3 and risk_factors:
            severity = "critical" if risk_score >= 0.7 else "high" if risk_score >= 0.5 else "medium"
            
            alert = UEBAAlert(
                alert_id=f"UEBA-{len(self.alerts)+1:04d}",
                entity_id=flow.source_ip,
                entity_type=profile.entity_type,
                risk_score=round(risk_score, 3),
                risk_factors=risk_factors,
                description=self._generate_alert_description(profile, risk_factors, evidence),
                evidence=evidence,
                severity=severity
            )
            
            # Update profile risk
            profile.risk_score = max(profile.risk_score, risk_score)
            profile.risk_factors = list(set(profile.risk_factors + risk_factors))
            profile.last_risk_update = datetime.now()
            
            self.alerts.append(alert)
            return alert
        
        return None
    
    def _calculate_peer_deviation(self, profile: BehaviorProfile, flow: NetworkFlow) -> float:
        """Calculate how much this entity deviates from its peer group"""
        peer_ids = self.peer_groups.get(profile.role, [])
        if len(peer_ids) < 2:
            return 0.0
        
        # Get peer destination patterns
        peer_destinations = set()
        for peer_id in peer_ids:
            if peer_id != profile.entity_id and peer_id in self.profiles:
                peer_destinations.update(self.profiles[peer_id].destinations.keys())
        
        # Check if this destination is unusual for peers
        if flow.dest_ip not in peer_destinations and len(peer_destinations) > 0:
            return 2.5  # High deviation
        
        return 0.0
    
    def _generate_alert_description(self, profile: BehaviorProfile, 
                                     risk_factors: List[str], evidence: dict) -> str:
        """Generate human-readable description for UEBA alert"""
        parts = [f"Behavioral anomaly detected for {profile.entity_type} {profile.entity_id} ({profile.role})."]
        
        if RiskFactor.UNUSUAL_TIME.value in risk_factors:
            parts.append(f"Activity at unusual hour ({evidence.get('unusual_hour', {}).get('current_hour', 'N/A')}) - normally inactive at this time.")
        
        if RiskFactor.FIRST_TIME_ACCESS.value in risk_factors:
            parts.append(f"First-time access to destination {evidence.get('new_destination', 'unknown')}.")
        
        if RiskFactor.UNUSUAL_VOLUME.value in risk_factors:
            vol_info = evidence.get('volume_deviation', {})
            parts.append(f"Traffic volume {vol_info.get('deviation_score', 0)}x above normal baseline.")
        
        if RiskFactor.PEER_DEVIATION.value in risk_factors:
            parts.append("Behavior significantly deviates from peer group patterns.")
        
        parts.append("This may indicate insider threat activity or compromised credentials.")
        
        return " ".join(parts)
    
    def detect_insider_threats(self) -> List[UEBAAlert]:
        """
        Scan all profiles for insider threat indicators.
        
        Indicators:
        - Data hoarding (high download volume)
        - Access to unusual resources
        - After-hours activity
        - Privilege escalation patterns
        """
        insider_alerts = []
        
        for entity_id, profile in self.profiles.items():
            if profile.observation_count < self.thresholds["min_observations_for_baseline"]:
                continue
            
            risk_factors = []
            evidence = {}
            risk_score = 0.0
            
            # Check for data hoarding
            total_bytes = sum(profile.hourly_bytes)
            peer_avg = self._get_peer_average_bytes(profile.role)
            if peer_avg > 0 and total_bytes > peer_avg * self.thresholds["data_hoarding_threshold"]:
                risk_factors.append(RiskFactor.DATA_HOARDING.value)
                risk_score += 0.4
                evidence["data_hoarding"] = {
                    "entity_bytes": total_bytes,
                    "peer_average": peer_avg,
                    "ratio": round(total_bytes / peer_avg, 2)
                }
            
            # Check for unusual resource access breadth
            unique_destinations = len(profile.destinations)
            peer_avg_destinations = self._get_peer_average_destinations(profile.role)
            if peer_avg_destinations > 0 and unique_destinations > peer_avg_destinations * 3:
                risk_factors.append("excessive_resource_access")
                risk_score += 0.3
                evidence["resource_breadth"] = {
                    "entity_destinations": unique_destinations,
                    "peer_average": peer_avg_destinations
                }
            
            if risk_score >= 0.4:
                alert = UEBAAlert(
                    alert_id=f"INSIDER-{len(insider_alerts)+1:04d}",
                    entity_id=entity_id,
                    entity_type=profile.entity_type,
                    risk_score=round(risk_score, 3),
                    risk_factors=risk_factors,
                    description=f"Potential insider threat detected: {profile.role} device {entity_id} "
                               f"shows data hoarding or excessive resource access patterns.",
                    evidence=evidence,
                    severity="high" if risk_score >= 0.6 else "medium"
                )
                insider_alerts.append(alert)
        
        self.alerts.extend(insider_alerts)
        return insider_alerts
    
    def _get_peer_average_bytes(self, role: str) -> float:
        """Get average bytes transferred by peers"""
        peer_ids = self.peer_groups.get(role, [])
        if not peer_ids:
            return 0.0
        
        total = 0.0
        count = 0
        for peer_id in peer_ids:
            if peer_id in self.profiles:
                total += sum(self.profiles[peer_id].hourly_bytes)
                count += 1
        
        return total / count if count > 0 else 0.0
    
    def _get_peer_average_destinations(self, role: str) -> float:
        """Get average number of destinations accessed by peers"""
        peer_ids = self.peer_groups.get(role, [])
        if not peer_ids:
            return 0.0
        
        total = 0
        count = 0
        for peer_id in peer_ids:
            if peer_id in self.profiles:
                total += len(self.profiles[peer_id].destinations)
                count += 1
        
        return total / count if count > 0 else 0.0
    
    def get_profile(self, entity_id: str) -> Optional[BehaviorProfile]:
        """Get a specific profile"""
        return self.profiles.get(entity_id)
    
    def get_all_profiles(self) -> List[dict]:
        """Get all profiles as dicts for API"""
        return [
            {
                "entity_id": p.entity_id,
                "entity_type": p.entity_type,
                "role": p.role,
                "zone": p.zone,
                "risk_score": round(p.risk_score, 3),
                "risk_factors": p.risk_factors,
                "observation_count": p.observation_count,
                "destinations_count": len(p.destinations),
                "first_seen": p.first_seen.isoformat(),
                "last_seen": p.last_seen.isoformat()
            }
            for p in self.profiles.values()
        ]
    
    def get_alerts(self) -> List[dict]:
        """Get all UEBA alerts as dicts"""
        return [
            {
                "alert_id": a.alert_id,
                "entity_id": a.entity_id,
                "entity_type": a.entity_type,
                "risk_score": a.risk_score,
                "risk_factors": a.risk_factors,
                "description": a.description,
                "evidence": a.evidence,
                "severity": a.severity,
                "timestamp": a.timestamp.isoformat()
            }
            for a in self.alerts
        ]
    
    def clear_alerts(self):
        """Clear all UEBA alerts"""
        self.alerts = []
